GC的出现

观察编程语言的发展，不难发现，易用性和友好性始终是一个主要的发展方向。汇编语言相对于机器语言提升了可读性，面向对象语言相对面向过程语言提升了对现实世界的贴近程度和可理解性。GC作为Java的代表功能之一，通过实现内存管理能力，让程序员可以更加专注业务。

WHAT：GC的含义

通常提到GC时，都指的是垃圾收集器（garbage collector），负责识别和清理无法被应用程序引用的对象。但从功能出发，GC更应该认为是内存管理器（memory management）。因为它不仅执行内存的回收整理，而是负责了内存的自动管理。“管理”包括分配，回收，整理等。“自动”则表明了这些操作不需要应用程序进行干预。

WHY：为什么需要GC

GC内存管理存在的意义在于将开发者从内存分配和垃圾收集的复杂性中屏蔽出来。

WHERE：GC发生在哪里

基于”分而治之“的管理思想，JVM对内存的管理也始于分块。根据存储内容的不同，将整个虚拟机内存分为堆、非堆和栈等区域。

GC工作在整个堆内存区域和非堆内存的部分区域中（如Metadata）。

WHEN：GC在什么时候发生

不同的GC收集器的触发条件不同，但最典型最直观的一个触发条件是当堆的剩余空间不够用于对象分配时（Allocation Failure）。其他发生时机例如堆的剩余空间达到某个阈值时，为了应用吞吐量而预先进行收集（Ergonomics）等。

HOW：GC是怎么做的

垃圾的识别：

当一个对象不能再从运行的程序中的任何指针到达时，它就被认为是垃圾了。

堆内存划分：

对于现在的应用程序，通常会被分配较大的堆内存，那么首要的问题就是堆内存的划分。研究发现，目前大部分应用程序中的对象的存活时间都满足以下三个假说：

1. 弱分代假说（Weak Generational Hypothesis）：大多数对象只能存活很短的时间。例如迭代器对象。
2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。例如Spring MVC中的各种单例的Bean对象。
3. 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

因此，多数GC对堆内存的划分方式都基于这三个假说。堆内存是根据对象的不同年龄进行分代管理的，整个区域被划分为新生代和老年代，同时这些代可以进行一些配置以满足特殊的要求。

代内存管理

当每一代的内存被填满时，就会进行垃圾回收。绝大多数对象被分配到一个专门用于年轻对象的池子里（年轻一代），而且大多数对象都死在那里。当年轻一代填满的时候，它会导致一个小规模的收集，其中只有年轻一代被收集；其他世代的垃圾不会被回收。假设弱代假设成立，并且年轻一代中的大多数对象都是垃圾，可以被回收，那么小规模收集可以被优化。这种收集的成本与被收集的活对象的数量成一阶比例；充满死对象的年轻一代会很快被收集。通常情况下，在每次小规模的收集过程中，年轻一代中幸存的一些对象会被转移到老一代中。最终，老一代的对象会被填满，必须被收集，从而导致大收集，在这个过程中，整个堆都被收集。主要收集通常比次要收集持续的时间要长得多，因为涉及的对象数量要大得多。

年轻一代由Eden和两个生存者空间组成。大多数对象最初都被分配在Eden中。一个生存者空间在任何时候都是空的，并作为Eden中任何活的对象的目的地；另一个生存者空间是在下一次复制集合期间的目的地。对象以这种方式在幸存者空间之间复制，直到它们的年龄足够大，可以被永久化（复制到永久化的一代）。

gc的选择：

为什么需要gc的选择和调优：

Amdahl's law定律。问题的并行加速率，受到问题中的顺序执行部分的影响。

对一个除gc外可完全扩展的应用，当对处理器进行线性扩展时，gc时间占比较高的应用程序，带来的性能收益却不会线性上升，其收益增长率会逐渐减少并趋于平缓。在小系统上开发时可以忽略不计的速度问题在扩展到大系统时可能成为主要瓶颈，在减少这种瓶颈方面的小改进可以在性能上产生大的收益。

gc的性能考虑

有两个衡量垃圾收集性能的主要标准。

吞吐量是指在很长一段时间内不用于垃圾收集的总时间的百分比。吞吐量包括花在分配上的时间（但通常不需要调整分配的速度）。

暂停是指由于正在进行垃圾收集而使应用程序看起来没有反应的时间。

不同类型的应用的要求不同。例如，有些人认为网络服务器的正确指标是吞吐量，因为垃圾收集期间的停顿可能是可以容忍的，或者只是被网络延迟掩盖了。然而，在一个交互式图形程序中，即使是短暂的停顿也可能对用户体验产生负面影响。

还有其他不同的考虑。足迹是指一个进程的工作集，以页数和缓存行数计算。在物理内存有限或许多进程的系统中，足迹可能决定了可扩展性。提示性是指一个对象变成死的时候和内存变成可用的时候之间的时间，这是分布式系统的一个重要考虑，包括远程方法调用（RMI）。

一般来说，为一个特定的世代选择大小是在这些考虑之间进行权衡。例如，一个非常大的年轻一代可能会最大限度地提高吞吐量，但这样做是以牺牲足迹、提示性和暂停时间为代价的。年轻一代的暂停时间可以通过使用一个小的年轻一代来最小化，但以牺牲吞吐量为代价。一代的大小并不影响另一代的收集频率和暂停时间。没有一个正确的方法来选择一代的大小。最佳的选择是由应用程序使用内存的方式以及用户需求决定的。

测量
吞吐量和占用空间最好用特定于应用的指标来衡量。例如，Web服务器的吞吐量可以使用客户端负载发生器进行测试，而服务器的足迹可以使用pmap命令在Solaris操作系统上进行测量。然而，通过检查虚拟机本身的诊断输出，可以很容易地估计出由于垃圾收集造成的停顿。



命令行选项-XX:+PrintGCDetails会导致打印关于收集的额外信息。

箭头前后的数字（例如，第一行的325407K->83000K）分别表示垃圾收集之前和之后的活对象的综合大小。在小规模收集之后，该大小包括一些属于垃圾（不再是活的）但不能被回收的对象。这些对象要么包含在持久化的一代中，要么是从持久化的一代中引用的。

括号中的下一个数字（例如，（776768K）还是第一行的数字）是堆的承诺大小：在不向操作系统请求更多内存的情况下，可用于Java对象的空间数量。请注意，这个数字只包括其中一个存活空间。除了在垃圾收集期间，在任何时候只有一个生存空间被用来存储对象。

这一行的最后一项（例如，0.2300771秒）表示执行收集的时间，在这种情况下，大约是四分之一秒。

选项-XX:+PrintGCTimeStamps在每个集合的开始处添加一个时间戳。这对查看垃圾收集的频率很有用。

代的大小

有许多参数会影响生成的大小。图4-1，"堆参数 "说明了堆中承诺空间和虚拟空间之间的区别。在虚拟机的初始化中，为堆保留了全部空间。保留空间的大小可以通过-Xmx选项来指定。如果-Xms参数的值小于-Xmx参数的值，那么并非所有被保留的空间都会立即提交给虚拟机。未提交的空间在本图中被标记为 "虚拟"。堆的不同部分（老年代和年轻代）可以根据需要增长到虚拟空间的极限。

有些参数是堆的一个部分与另一个部分的比值。例如，参数NewRatio表示终身一代与年轻一代的相对大小。

总堆
下面关于堆的增长和缩小以及默认堆大小的讨论并不适用于并行收集器。(参见 "确定世代大小 "中的 "并行收集器人机工程学 "一节，以了解关于并行收集器的堆大小调整和默认堆大小的详细信息)。然而，控制堆的总大小和各代的大小的参数确实适用于并行收集器。

影响垃圾收集性能的最重要因素是总的可用内存。因为收集是在代填满时发生的，所以吞吐量与可用的内存量成反比。

默认情况下，虚拟机在每个集合处增长或收缩堆，试图将每个集合处的自由空间与活对象的比例保持在一个特定范围内。这个目标范围由参数-XX:MinHeapFreeRatio=<最小>和-XX:MaxHeapFreeRatio=<最大>设置为一个百分比，总大小下面由-Xms<min>限定，上面由-Xmx<max>限定。64位Solaris操作系统（SPARC平台版）的默认参数显示在表4-1，"64位Solaris操作系统的默认参数"。

表4-1 64位Solaris操作系统的默认参数

参数 默认值
最小堆空闲率（MinHeapFreeRatio

40

MaxHeapFreeRatio

70

-Xms

6656k

-Xmx

计算


有了这些参数，如果代中的自由空间百分比低于40%，那么这一代将被扩大，以保持40%的自由空间，但以这一代的最大允许大小为限。同样地，如果自由空间超过70%，那么这一代将被收缩，使其只有70%的空间是自由的，但要符合这一代的最小尺寸。

正如表4-1"64位Solaris操作系统的默认参数 "中所指出的，默认的最大堆大小是一个由JVM计算的值。Java SE中用于并行收集器和服务器JVM的计算方法现在被用于所有的垃圾收集器。计算的一部分是最大堆大小的上限，该上限在32位平台和64位平台上是不同的。参见《并行收集器》中的默认堆大小一节。客户端JVM也有类似的计算方法，它的最大堆尺寸比服务器JVM的小。

以下是关于服务器应用程序的堆大小的一般准则。

除非你有暂停的问题，否则尽量给虚拟机授予尽可能多的内存。默认的大小往往太小。

将-Xms和-Xmx设置为相同的值可以通过从虚拟机中删除大小调整决策来提高可预测性。然而，如果您做出了错误的选择，虚拟机将无法进行补偿。

一般来说，随着处理器数量的增加而增加内存，因为分配是可以平行进行的。

年轻代
在总可用内存之后，影响垃圾收集性能的第二大因素是堆中用于年轻代的比例。年轻代越大，就越不容易发生ygc。然而，对于一个总大小有约束的堆，较大的年轻代意味着较小的永久代，这将增加fgc的频率。最佳选择取决于应用程序分配的对象的寿命分布。

默认情况下，年轻代的大小是由参数NewRatio控制的。例如，设置-XX:NewRatio=3意味着年轻代和老年代的比例为1:3。换句话说，eden和survive空间的总大小将是总堆大小的四分之一。

参数NewSize和MaxNewSize从下方和上方约束年轻代的大小。将这些参数设置为相同的值可以固定年轻一代，就像将-Xms和-Xmx设置为相同的值可以固定总堆的大小。这有助于在比NewRatio允许的整数倍更细的粒度上调整年轻代。

幸存者空间大小
你可以使用参数SurvivorRatio来调整生存空间的大小，但这对于性能来说往往并不重要。例如，-XX:SurvivorRatio=6将伊甸园和幸存者空间的比例设定为1:6。换句话说，每个生存者空间将是伊甸园大小的六分之一，因此是年轻一代大小的八分之一（不是七分之一，因为有两个生存者空间）。

如果幸存者空间太小，复制的集合会直接溢出到老年代中。如果生存者空间太大，它们会无用地空出来。在每次垃圾收集时，虚拟机都会选择一个阈值，也就是一个对象在被终结前可以被复制的次数。这个阈值的选择是为了保持生存空间的半满。命令行选项-XX:+PrintTenuringDistribution（不是所有的垃圾收集器都可用）可以用来显示这个阈值和新一代对象的年龄。它对于观察一个应用程序的寿命分布也很有用。

表4-2，"生存空间大小的默认参数值 "提供了64位Solaris的默认值。

表4-2 生存空间大小的默认参数值

参数 服务器 JVM 默认值
NewRatio
2

NewSize
1310M

MaxNewSize
无限制

SurvivorRatio
8

年轻一代的最大尺寸将根据总堆的最大尺寸和NewRatio参数的值来计算。MaxNewSize参数的 "不限制 "默认值意味着计算值不受MaxNewSize的限制，除非在命令行中指定MaxNewSize的值。

以下是服务器应用程序的一般准则。

首先决定你能承受的给虚拟机的最大堆大小。然后将你的性能指标与年轻代的大小作对比，找到最佳设置。

请注意，最大的堆大小应该总是小于安装在机器上的内存量，以避免过多的页面故障和激动page faults and thrashing.。

如果总的堆的大小是固定的，那么增加年轻一代的大小就需要减少老年代的大小。保持年轻代的大小足以容纳应用程序在任何时候使用的所有实时数据，再加上一定量的闲置空间（10-20%或更多）。

在遵守前面所说的对老年代的限制的前提下：

给年轻代提供足够的内存。

随着处理器数量的增加，增加年轻一代的规模，因为分配是可以并行的。

可用的收集者
到目前为止的讨论都是关于串行收集器的。Java HotSpot VM包括三种不同类型的收集器，每一种都有不同的性能特点。

串行收集器使用单个线程来执行所有的垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。它最适合于单处理器机器，因为它不能利用多处理器硬件的优势，尽管它在多处理器上对小数据集（最大约100MB）的应用很有用。串行采集器在某些硬件和操作系统配置中被默认选择，或者可以通过选项-XX:+UseSerialGC明确启用。

并行收集器（也被称为吞吐量收集器）以并行方式执行ygc，这可以大大减少垃圾收集的开销。它适用于在多处理器或多线程硬件上运行的具有中型到大型数据集的应用程序。并行收集器在某些硬件和操作系统配置中被默认选择，或者可以通过选项-XX:+UseParallelGC明确启用。

​	并行压实Parallel compaction是一个使并行收集器能够并行地进行fgc的功能。如果没有并行压实，主要的收集是使用单线程进行的，这可能会大大限制扩展性。如果指定了选项-XX:+UseParallelGC，那么默认情况下会启用并行压实功能。关掉它的选项是-XX:-UseParallelOldGC。

大部分的并发收集器都是并发地执行大部分的工作（例如，当应用程序仍在运行时），以保持垃圾收集的短暂暂停。它是为具有中型到大型数据集的应用而设计的，在这些应用中，响应时间比总体吞吐量更重要，因为用于最小化暂停的技术会降低应用性能。Java HotSpot VM提供了两种大部分并发收集器的选择；见大部分并发收集器。使用选项-XX:+UseConcMarkSweepGC来启用CMS收集器，或-XX:+UseG1GC来启用G1收集器。

选择一个收集器
除非您的应用程序有相当严格的暂停时间要求，否则首先运行您的应用程序并允许虚拟机选择一个收集器。如果有必要，调整堆的大小以提高性能。如果性能仍然不符合您的目标，那么请使用以下指南作为选择收集器的起点。

如果应用程序有一个小的数据集（最多大约100MB），那么

用选项-XX:+UseSerialGC选择串行采集器。

如果应用程序将在单个处理器上运行，并且没有暂停时间的要求，那么就让虚拟机选择收集器，或者用选项-XX:+UseSerialGC选择串行收集器。

如果（a）应用程序的峰值性能是首要任务，并且（b）没有暂停时间的要求，或者可以接受1秒或更长的暂停时间，那么就让虚拟机选择收集器，或者用-XX:+UseParallelGC选择并行收集器。

如果响应时间比总体吞吐量更重要，而且垃圾收集暂停时间必须保持在1秒左右，那么就用-XX:+UseConcMarkSweepGC或-XX:+UseG1GC选择并发收集器。

这些指南只提供了选择收集器的起点，因为性能取决于堆的大小、应用程序维护的实时数据量，以及可用处理器的数量和速度。暂停时间对这些因素特别敏感，所以前面提到的1秒的阈值只是近似值：并行收集器在许多数据大小和硬件组合上的暂停时间会超过1秒；反之，并发收集器在某些组合上的暂停时间可能无法保持在1秒以内。

如果推荐的收集器没有达到预期的性能，首先尝试调整堆和生成器的大小，以满足预期的目标。如果性能仍然不足，那么尝试不同的收集器：使用并发收集器来减少暂停时间，使用并行收集器来增加多处理器硬件上的整体吞吐量。
