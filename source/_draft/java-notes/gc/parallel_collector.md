并行收集器（吞吐量收集器）是一个类似于串行收集器的生成收集器；主要区别是使用多个线程来加速垃圾收集。并行收集器是通过命令行选项-XX:+UseParallelGC启用的。默认情况下，在这个选项下，小收集和大收集都是并行执行的，以进一步减少垃圾收集的开销。

在有N个硬件线程的机器上，如果N大于8，并行收集器使用N的一个固定分数作为垃圾收集器线程的数量。在N值低于8的情况下，使用的数字是N，在选定的平台上，该分数下降到5/16。垃圾收集器线程的具体数量可以用一个命令行选项来调整（后面将介绍）。在只有一个处理器的主机上，由于并行执行所需的开销（例如，同步），并行收集器的性能可能不如串行收集器好。然而，当运行具有中型到大型堆的应用程序时，在具有两个处理器的机器上，它通常比串行收集器的性能好一些，而当有两个以上的处理器时，通常比串行收集器的性能好得多。

垃圾收集器线程的数量可以通过命令行选项-XX:ParallelGCThreads=<N>来控制。如果用命令行选项对堆进行显式调整，那么使用并行收集器获得良好性能所需的堆的大小与使用串行收集器所需的相同。然而，启用并行收集器应该使收集暂停的时间缩短。由于多个垃圾收集器线程参与了一个小型收集，在收集过程中，由于从年轻一代晋升到长期一代，可能会出现一些碎片化。每个参与小规模收集的垃圾收集线程都会为晋升保留一部分老一代的垃圾，将可用空间划分到这些 "晋升缓冲区 "会导致碎片化效应。减少垃圾收集器线程的数量，并增加固化代的大小将减少这种碎片化效应。

并行收集器的人机工程学
在服务器级机器上默认选择了并行收集器。此外，并行收集器使用一种自动调整的方法，允许你指定具体的行为，而不是生成大小和其他低级别的调整细节。你可以指定最大垃圾收集暂停时间、吞吐量和足迹（堆大小）。

最大的垃圾收集暂停时间：最大的暂停时间目标是通过命令行选项-XX:MaxGCPauseMillis=<N>指定的。这被解释为一个提示，即希望暂停时间为<N>毫秒或更少；默认情况下，没有最大暂停时间目标。如果指定了暂停时间的目标，堆的大小和其他与垃圾收集有关的参数会被调整，以试图使垃圾收集暂停时间短于指定的值。这些调整可能会导致垃圾收集器降低应用程序的整体吞吐量，而且所需的暂停时间目标不能总是得到满足。

吞吐量。吞吐量目标是用做垃圾收集的时间与垃圾收集之外的时间（称为应用时间）来衡量的。该目标由命令行选项-XX:GCTimeRatio=<N>指定，该选项将垃圾收集时间与应用时间的比率设定为1/（1+<N>）。

例如，-XX:GCTimeRatio=19设定的目标是1/20或垃圾收集总时间的5%。默认值是99，结果是垃圾收集时间的1%。

脚印。使用选项-Xmx<N>来指定最大的堆占用率。此外，只要其他目标得到满足，收集器有一个隐含的目标，即最小化堆的大小。

目标的优先次序
这些目标按以下顺序处理。

最大停顿时间目标

吞吐量目标

最小足迹目标

最大停顿时间的目标首先得到满足。只有在它得到满足之后，才会考虑吞吐量目标。同样，只有在满足了前两个目标后，才考虑占地面积目标。

代大小调整
收集器保存了统计数据，如平均暂停时间，会在每次采集结束时更新。然后进行测试以确定是否达到了目标，并对代的大小进行适当的调整。例外的情况是，显式的垃圾收集（例如，对System.gc()的调用）在保持统计和对一代的大小进行调整方面被忽略。

增长和缩小一代人的规模是通过增量完成的，增量是一代人规模的固定百分比，以便一代人向上或向下走向其所需的规模。增长和缩小是以不同的速度进行的。默认情况下，代以20%的增量增长，以5%的增量缩减。增长的百分比由命令行选项-XX:YoungGenerationSizeIncrement=<Y>控制，用于年轻一代；-XX:TenuredGenerationSizeIncrement=<T>用于长期一代。一代人缩减的百分比由命令行标志-XX:AdaptiveSizeDecrementScaleFactor=<D>来调整。如果增长的增量是X%，那么缩减的减量就是X/D%。

如果收集器决定在启动时增长一代，那么会有一个补充百分比被添加到增量中。这个补充会随着收集次数的增加而衰减，没有长期影响。补充的目的是为了提高启动性能。对缩减的百分比没有补充。

如果没有达到最大暂停时间的目标，那么每次只缩减一代的规模。如果两代人的暂停时间都高于目标，那么暂停时间较大的一代人的规模首先被缩减。

如果没有达到吞吐量目标，两代人的规模都会增加。每一个都按其各自对总垃圾收集时间的贡献比例增加。例如，如果年轻一代的垃圾收集时间占总收集时间的25%，如果年轻一代的完全增量将是20%，那么年轻一代将被增加5%。

默认的堆大小
除非在命令行中指定初始和最大堆大小，否则它们是根据机器上的内存量计算的。

客户端JVM默认的初始和最大堆大小
对于最高为192兆字节（MB）的物理内存，默认的最大堆大小是物理内存的一半；否则为物理内存的四分之一，最高为1千兆字节（GB）的物理内存。

例如，如果你的计算机有128MB的物理内存，那么最大堆大小为64MB，大于或等于1GB的物理内存导致最大堆大小为256MB。

除非你的程序创建了足够多的对象来要求它，否则JVM实际上不会使用最大堆大小。在JVM初始化过程中，会分配一个小得多的数量，称为初始堆大小。这个大小至少为8MB，否则为物理内存的1/64，最大物理内存大小为1GB。

分配给年轻一代的最大空间量是总堆大小的三分之一。

服务器JVM默认的初始和最大堆大小
默认的初始和最大堆大小在服务器JVM上的作用与在客户端JVM上的作用类似，只是默认值可以更高。在32位JVM上，如果有4GB或以上的物理内存，默认的最大堆大小可以达到1GB。在64位JVM上，如果有128GB或以上的物理内存，默认的最大堆大小可以达到32GB。你总是可以通过直接指定这些值来设置一个更高或更低的初始和最大堆，见下一节。

指定初始和最大堆的大小
你可以使用标志-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始和最大堆的大小。如果你知道你的应用程序需要多少堆才能正常工作，你可以将-Xms和-Xmx设置为相同的值。如果不是，JVM将从使用初始堆大小开始，然后增长Java堆，直到在堆的使用和性能之间找到一个平衡。

其他参数和选项可以影响这些默认值。要验证你的默认值，使用-XX:+PrintFlagsFinal选项，在输出中寻找MaxHeapSize。例如，在Linux或Solaris上，你可以运行以下程序。

java -XX:+PrintFlagsFinal <GC选项> -version | grep MaxHeapSize



过多的GC时间和OutOfMemoryError
如果在垃圾收集（GC）中花费了太多的时间，并行收集器会抛出OutOfMemoryError。如果超过98%的时间花在了垃圾收集上，并且不到2%的堆被恢复，那么就会抛出OutOfMemoryError。这个功能是为了防止应用程序在运行了很长一段时间后，由于堆太小而几乎没有进展。如果有必要，可以通过在命令行中添加选项-XX:-UseGCOverheadLimit来禁用这个功能。

测量
并行收集器的粗略垃圾收集器输出与串行收集器的输出基本相同。
