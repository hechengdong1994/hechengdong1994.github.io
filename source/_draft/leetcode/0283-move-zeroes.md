# move-zeroes

https://leetcode-cn.com/problems/move-zeroes/

## 1 额外数组存储

由于需要保证非零元素的相对顺序，因此，只需要按原有顺序将非零元素保存下来，后面的位置都置为0。

```java
public int[] moveZeroes(int[] nums) {
    // 声明与原数组相同大小的结果数组
    int[] result = new int[nums.length];
    // 指向最后一个非0数的下一个位置，初始时没有任何数被处理好，因此初始值为0。
    int j = 0;
    // 遍历原数组
    for (int num : nums) {
        // 保存非0数，保证相对顺序
        if (num != 0) {
            result[j++] = num;
        }
    }
    // 多余元素均为0
    for (; j < result.length; j++) {
        result[j] = 0;
    }
    // 返回结果
    return result;
}
```

该方法的时间复杂度为O(n+k)，k为数组中0元素的个数；空间复杂度为O(n)，因为申请了额外数组。

### 1.1 原数组操作优化

由于题干中要求需要在原数组上进行操作，因此无法重新声明新数组进行操作。原方法中先查找并按原相对顺序排列，再对多余位置补0的思路，在原数组中依然可以使用。

```java
public void moveZeroes(int[] nums) {
    // 指向最后一个非0数的下一个位置，初始时没有任何数被处理好，因此初始值为0。
    int j = 0;
    // 遍历原数组
    for (int i = 0; i < nums.length; i++) {
        // 前移非0数，保证相对顺序
        if (nums[i] != 0) {
            nums[j++] = nums[i];
        }
    }
    // 多余元素均为0
    for (; j < nums.length; j++) {
        nums[j] = 0;
    }
}
```

修改后的时间复杂度依然为O(n+k)，k为数组中0元素的个数；空间复杂度为O(1)，且满足题干要求。

## 2 数据交换

进一步考虑是否能够优化方法1中时间复杂度中的k。也就是说，是否能去掉对数组中的非0元素排列后的后续位置的补0操作。即只需要遍历一次原数组，就可以处理好0和非0元素的位置关系。

可以看出，在之前的方法中，都没有对0进行考虑，只是处理了非0元素的相对顺序。

因此优化思路是，在对非0操作进行处理时，能否同时考虑到0的处理。

显然地，对非0元素不使用简单的赋值覆盖，而是使用数据交换的方式进行处理即可。

```java
public void moveZeroes(int[] nums) {
    // 慢指针，指向数组中已处理好的最后一个非0数的下一个数。
    // 初始时，认为数组中没有任何数被处理好，即数组中已处理好的最后一个非0数的下标为-1，因此慢指针初始值为0，
    int j = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            // 交换两个元素的位置，实现了非0数的前移，同时也处理了0元素的后移
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
            // 慢指针指向下一个位置
            j++;
        }
    }
}
```

因为对n中的每个值只进行了一次处理，因此该方法的时间复杂度为O(n)；同时满足了在原数组上操作的要求。

### 2.1 i=j情况优化

题干中还有一个【尽量减少操作次数】的要求。在方法2中，可能会出现当i==j时依然进行交换的处理。因此可以通过判断以省去这个情况下的数据交换操作。

```java
public void moveZeroes(int[] nums) {
    // 慢指针，指向数组中已处理好的最后一个非0数的下一个数。
    // 初始时，认为数组中没有任何数被处理好，即数组中已处理好的最后一个非0数的下标为-1，因此慢指针初始值为0，
    int j = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            // 若快指针在慢指针前头，才进行数据交换，避免了i==j时的无效数据交换
            if (i > j) {
                // 交换两个元素的位置，实现了非0数的前移，同时也处理了0元素的后移
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
            // 慢指针指向下一个位置
            j++;
        }
    }
}
```

