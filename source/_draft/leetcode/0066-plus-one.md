# plus-one

https://leetcode-cn.com/problems/plus-one/

## 1 逐位计算

算法思路：

该问题的重难点在于对进位的处理。和实际做加法的思路一样，从最后一位开始逐位进行加一的处理，若需要进位，则继续对前一位进行处理；当第一次出现不需要进位时，本次的加法计算也就结束了。

额外考虑一种每位数字都是9的特殊情况，即9,99,999,...。当出现这种情况时，需要进行手动的进位，即原有数组长度不够了，需要申请长度+1的新数组，并且只要将新数组的第一位置为1即可。

算法流程：

1. 从数组最后一位开始进入循环
   1. 对当前位的数进行+1计算，并对10取余。
   2. 若取余后结果为0，表示之前该位数字为9，+1之后为10，需要进位，则继续循环，对前一位进行计算；若取余后结果不为0，表示不需要进位了，则对该数组的+1运算也就结束了，可以直接返回结果数组。
3. 退出循环，表示当前每一位都发生了进位，也就是各位都是9的特殊情况的处理，申请一个长度较原数组长度+1的新数组，将索引0位置的元素设为1，即完成了计算。

```java
public int[] plusOne(int[] digits) {
    // 逐位计算
    for (int i = digits.length - 1; i >= 0; i--) {
        // 该位进行+1
        digits[i]++;
        // 对10取余得到个位数
        digits[i] = digits[i] % 10;
        // 若个位数不为0，表示不需要进位，则本次计算结束
        if (digits[i] != 0) return digits;
    }
    // 循环结束，表示每一位都发生了进位，即各位都是9的特殊情况
    // 手工进位，申请长度+1的新数组
    digits = new int[digits.length + 1];
    // 新数组的首位值为1，即完成了计算
    digits[0] = 1;
    return digits;
}
```

该方法的时间复杂度为O(n)，n为数组长度；对于空间复杂度，普通情况下为O(1)，特殊情况下为O(n)，则平均的空间复杂度依然为O(n)。