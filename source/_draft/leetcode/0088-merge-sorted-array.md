# merge-sorted-array

https://leetcode-cn.com/problems/merge-sorted-array/

## 1 双指针-从后往前合并

算法流程：

1. 双指针i,j起始指向两个数组需要合并的最后一个元素，即m/n-1；另一指针k指向合并后的最后一个位置，即k=m+n-1
4. 当m/n均>0时，表示两个数组都还有数据需要进行合并，进入循环
   1. 比较i,j对应元素大小，将较大的数据放入指针k对应位置，并将k前移
   2. 对于较大的数组，指针（i/j）--，需要排序的元素个数（m/n）--
3. 循环结束后，对还没有处理完的数组，将剩余的元素补充到结果数组中（由于结果数组就是入参nums1，因此如果是nums1中有剩余元素，则不需要补充）

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    // 双指针分别指向两个数组中需要合并的最后一个元素
    int i = m - 1;
    int j = n - 1;
    // 指针k表示当前插入元素的位置，初始值为两个数组需要合并的元素个数之和-1
    int k = m + n - 1;
    // 当两个数组都还有元素需要进行合并时，进入循环
    for (; m > 0 && n > 0; ) {
        // 将较大的元素放入结果数组
        if (nums1[i] >= nums2[j]) {
            // 写入元素，写入位置前移
            nums1[k--] = nums1[i];
            // 该数组的待处理指针前移
            i--;
            // 该数组的待处理个数-1
            m--;
        } else {
            nums1[k--] = nums2[j];
            j--;
            n--;
        }
    }
    // 若数组2中还有多余未处理的元素，直接放入结果数组中
    if (n > 0) {
        for (; j >= 0; j--) {
            nums1[k--] = nums2[j];
        }
    }
}
```

该方法的时间复杂度为O(m+n)，空间复杂度为O(1)。满足题干要求。
