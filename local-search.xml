<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Druid连接池的可用性检测能力暴露MySQL驱动程序Fabric连接NullPointerException问题分析</title>
    <link href="/druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B%E6%9A%B4%E9%9C%B2mysql%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8Ffabric%E8%BF%9E%E6%8E%A5nullpointerexception%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B%E6%9A%B4%E9%9C%B2mysql%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8Ffabric%E8%BF%9E%E6%8E%A5nullpointerexception%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>数据库连接池组件已经成为服务端应用中进行数据库连接管理在事实上的标准方案。而引入新组件的同时自然也引入了更多的风险。本文尝试解决一个由连接池版本升级引发驱动程序抛出NullPointerException导致项目无法启动的问题。以异常堆栈作为排查依据，通过查看源码和构建复现场景的手段确认问题发生的根本原因，并尝试在该问题涉及到的不同层面提出合理可行的解决方案。进一步的，还继续深入研究了其他连接池的相关实现，以分析其没有引发该异常的原因。</p><span id="more"></span><h1 id="1-现象描述"><a href="#1-现象描述" class="headerlink" title="1 现象描述"></a>1 现象描述</h1><p>将项目中使用的Druid连接池版本从1.1.22升级到1.2.15后项目无法启动。</p><p>异常堆栈如下（省略部分spring堆栈并隐去部分信息）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&#123;dataSource-<span class="hljs-number">49</span>&#125; init error<br>java<span class="hljs-selector-class">.sql</span><span class="hljs-selector-class">.SQLException</span>: validateConnection false<br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.validateConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1461</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.createPhysicalConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1812</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.init</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">914</span>) <span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.getConnection</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1433</span>) <span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br><br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.StatementImpl<span class="hljs-variable">$CancelTask</span>.&lt;init&gt;(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.30.jar:?]</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.StatementImpl</span><span class="hljs-selector-class">.executeQuery</span>(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1541</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.30.jar:?]</span><br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method) ~<span class="hljs-selector-attr">[?:1.8.0_281]</span><br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>) ~<span class="hljs-selector-attr">[?:1.8.0_281]</span><br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>) ~<span class="hljs-selector-attr">[?:1.8.0_281]</span><br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span><span class="hljs-selector-class">.invoke</span>(Method<span class="hljs-selector-class">.java</span>:<span class="hljs-number">498</span>) ~<span class="hljs-selector-attr">[?:1.8.0_281]</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.LoadBalancingConnectionProxy<span class="hljs-variable">$ConnectionErrorFiringInvocationHandler</span><span class="hljs-selector-class">.invoke</span>(LoadBalancingConnectionProxy<span class="hljs-selector-class">.java</span>:<span class="hljs-number">107</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.30.jar:?]</span><br>at com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy164</span><span class="hljs-selector-class">.executeQuery</span>(Unknown Source) ~<span class="hljs-selector-attr">[?:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.vendor</span><span class="hljs-selector-class">.MySqlValidConnectionChecker</span><span class="hljs-selector-class">.isValidConnection</span>(MySqlValidConnectionChecker<span class="hljs-selector-class">.java</span>:<span class="hljs-number">140</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.validateConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1440</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>... <span class="hljs-number">118</span> more<br></code></pre></td></tr></table></figure><h1 id="2-配置收集"><a href="#2-配置收集" class="headerlink" title="2 配置收集"></a>2 配置收集</h1><p>作为底层服务的维护人员，当上层的使用方报告问题时，首先要做的就是尽可能完整的收集相关信息以复现问题。在这个问题中，收集了从连接池到MySQL服务器之间的各层组件的版本及配置信息。</p><ol><li><p>Druid连接池版本：1.1.22和1.2.15</p></li><li><p>Druid连接池配置（根据后续的排查情况，此处省略部分不相关配置项）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;initialSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;maxActive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">50</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;minIdle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;maxWait&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;validationQuery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SELECT 1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;validationQueryTimeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;testOnBorrow&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;testOnReturn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;testWhileIdle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;timeBetweenEvictionRunsMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;minEvictableIdleTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">30000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;maxEvictableIdleTimeMillis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100000</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>MySQL Connector&#x2F;J连接方式：连接协议为<code>jdbc:mysql:fabric://</code>，对应的Driver实现类为<code>com.mysql.fabric.jdbc.FabricMySQLDriver</code>，由Driver构造出的Connection实现类为<code>com.mysql.fabric.jdbc.FabricMySQLConnectionProxy</code>(主要逻辑)和<code>com.mysql.fabric.jdbc.JDBC4FabricMySQLConnectionProxy</code>。</p></li><li><p>MySQL Connector&#x2F;J驱动版本：5.1.49版本。（实际项目使用的是经过二次开发的5.1.30版本，但经后续测试，直至最新的5.1.49版本的驱动都存在该问题）</p></li><li><p>MySQL服务：5.7版本。使用Fabric服务作为集群管理方案。</p></li></ol><h1 id="3-异常复现"><a href="#3-异常复现" class="headerlink" title="3 异常复现"></a>3 异常复现</h1><p>根据上述配置，构造Druid连接池实例，并调用方法获取连接，即可复现该异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        properties.put(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;jdbc:mysql:fabric://&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;driverClassName&quot;</span>, <span class="hljs-string">&quot;com.mysql.fabric.jdbc.FabricMySQLDriver&quot;</span>);<br><br>        properties.put(<span class="hljs-string">&quot;initialSize&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;maxActive&quot;</span>, <span class="hljs-string">&quot;50&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;minIdle&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;maxWait&quot;</span>, <span class="hljs-string">&quot;3000&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;validationQuery&quot;</span>, <span class="hljs-string">&quot;SELECT 1&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;validationQueryTimeout&quot;</span>, <span class="hljs-string">&quot;3000&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;testOnBorrow&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;testOnReturn&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;testWhileIdle&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;timeBetweenEvictionRunsMillis&quot;</span>, <span class="hljs-string">&quot;60000&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;minEvictableIdleTimeMillis&quot;</span>, <span class="hljs-string">&quot;30000&quot;</span>);<br>        properties.put(<span class="hljs-string">&quot;maxEvictableIdleTimeMillis&quot;</span>, <span class="hljs-string">&quot;100000&quot;</span>);<br><br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        DruidDataSourceFactory.config(dataSource, properties);<br><br>        dataSource.getConnection(); <span class="hljs-comment">// 抛出异常</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到与实际项目的异常堆栈相同：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&#123;dataSource-<span class="hljs-number">1</span>&#125; init error<br>java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span>: null<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.StatementImpl<span class="hljs-variable">$CancelTask</span>.&lt;init&gt;(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.30.jar:?]</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.StatementImpl</span><span class="hljs-selector-class">.executeQuery</span>(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1546</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.30.jar:?]</span><br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method) ~<span class="hljs-selector-attr">[?:1.8.0_202]</span><br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>) ~<span class="hljs-selector-attr">[?:1.8.0_202]</span><br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>) ~<span class="hljs-selector-attr">[?:1.8.0_202]</span><br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span><span class="hljs-selector-class">.invoke</span>(Method<span class="hljs-selector-class">.java</span>:<span class="hljs-number">498</span>) ~<span class="hljs-selector-attr">[?:1.8.0_202]</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.LoadBalancingConnectionProxy<span class="hljs-variable">$ConnectionErrorFiringInvocationHandler</span><span class="hljs-selector-class">.invoke</span>(LoadBalancingConnectionProxy<span class="hljs-selector-class">.java</span>:<span class="hljs-number">107</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.30.jar:?]</span><br>at com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy21</span><span class="hljs-selector-class">.executeQuery</span>(Unknown Source) ~<span class="hljs-selector-attr">[?:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.validateConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1476</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.createPhysicalConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1812</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.init</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">914</span>) <span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.getConnection</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1433</span>) <span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidDataSource</span><span class="hljs-selector-class">.getConnection</span>(DruidDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1429</span>) <span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at <span class="hljs-selector-tag">main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">34</span>) <span class="hljs-selector-attr">[classes/:?]</span><br></code></pre></td></tr></table></figure><h1 id="4-排查过程"><a href="#4-排查过程" class="headerlink" title="4 排查过程"></a>4 排查过程</h1><p>该异常是由升级Druid连接池引起的，因此首先考虑是新版本连接池对驱动程序的不当使用导致了异常。</p><h2 id="4-1-首先从连接池层面排查版本升级后抛出异常的原因"><a href="#4-1-首先从连接池层面排查版本升级后抛出异常的原因" class="headerlink" title="4.1 首先从连接池层面排查版本升级后抛出异常的原因"></a>4.1 首先从连接池层面排查版本升级后抛出异常的原因</h2><p>跟踪异常堆栈中连接池的相关方法调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.vendor</span><span class="hljs-selector-class">.MySqlValidConnectionChecker</span><span class="hljs-selector-class">.isValidConnection</span>(MySqlValidConnectionChecker<span class="hljs-selector-class">.java</span>:<span class="hljs-number">140</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br>at com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.druid</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.DruidAbstractDataSource</span><span class="hljs-selector-class">.validateConnection</span>(DruidAbstractDataSource<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1440</span>) ~<span class="hljs-selector-attr">[druid-1.2.15.jar:?]</span><br></code></pre></td></tr></table></figure><p>查看<code>MySqlValidConnectionChecker.isValidConnection</code>的验证逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    stmt = conn.createStatement();<br>    <span class="hljs-keyword">if</span> (validationQueryTimeout &gt; <span class="hljs-number">0</span>) &#123;<br>        stmt.setQueryTimeout(validationQueryTimeout);<br>    &#125;<br>    rs = stmt.executeQuery(query); <span class="hljs-comment">// 此处抛出NPE</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    JdbcUtils.close(rs);<br>    JdbcUtils.close(stmt);<br>&#125;<br></code></pre></td></tr></table></figure><p>继续查看外层<code>com.alibaba.druid.pool.DruidAbstractDataSource#validateConnection</code>对异常的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (validConnectionChecker != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">boolean</span> result;<br>    <span class="hljs-type">Exception</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        result = validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout);<br><br>        <span class="hljs-keyword">if</span> (result &amp;&amp; onFatalError) &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (onFatalError) &#123;<br>                    onFatalError = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (SQLException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        result = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 在1.1.22版本中没有这句，因此升级之前没有抛出异常</span><br>        error = ex;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>        <span class="hljs-type">SQLException</span> <span class="hljs-variable">sqlError</span> <span class="hljs-operator">=</span> error != <span class="hljs-literal">null</span> ? <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">&quot;validateConnection false&quot;</span>, error) <span class="hljs-comment">//</span><br>            : <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">&quot;validateConnection false&quot;</span>);<br>        <span class="hljs-keyword">throw</span> sqlError; <span class="hljs-comment">// 抛出异常</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>对比升级前后两个版本可以看出，1.2.15版本对于非SQLException异常也向上抛出，而在旧的1.1.22版本对于非SQLException的异常没有抛出（从实现逻辑推测应该是实现上的bug）。</p><p>因此，<strong>虽然是升级连接池版本后出现的异常，但异常实际是由驱动程序抛出，连接池只是将异常进行向上传递。</strong></p><h2 id="4-2-继续跟踪驱动程序抛出NullPointerException的原因"><a href="#4-2-继续跟踪驱动程序抛出NullPointerException的原因" class="headerlink" title="4.2 继续跟踪驱动程序抛出NullPointerException的原因"></a>4.2 继续跟踪驱动程序抛出NullPointerException的原因</h2><p>跟踪异常堆栈中与驱动程序相关的部分</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.StatementImpl<span class="hljs-variable">$CancelTask</span>.&lt;init&gt;(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.xx.jar:?]</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.StatementImpl</span><span class="hljs-selector-class">.executeQuery</span>(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1546</span>) ~<span class="hljs-selector-attr">[mysql-connector-java-5.1.xx.jar:?]</span><br></code></pre></td></tr></table></figure><p>首先看<code>com.mysql.jdbc.StatementImpl.CancelTask</code>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">CancelTask(StatementImpl cancellee) <span class="hljs-keyword">throws</span> SQLException &#123;<br>    connectionId = cancellee.connectionId;<br>    origHost = connection.getHost();<br>    toCancel = cancellee;<br>    origConnProps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br><br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> StatementImpl.<span class="hljs-built_in">this</span>.connection.getProperties(); <span class="hljs-comment">// 此处connection.getProperties()返回了null</span><br><br>    Enumeration&lt;?&gt; keys = props.propertyNames(); <span class="hljs-comment">// 导致此处抛出NPE异常</span><br><br>    <span class="hljs-keyword">while</span> (keys.hasMoreElements()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keys.nextElement().toString();<br>        origConnProps.setProperty(key, props.getProperty(key));<br>    &#125;<br><br>    origConnURL = connection.getURL();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出是由于所使用的Connection实现类<code>com.mysql.fabric.jdbc.FabricMySQLConnectionProxy</code>的<code>getProperties()</code>方法返回null导致了异常。</p><p>继续看<code>com.mysql.jdbc.StatementImpl#executeQuery</code>中进行<code>CancelTask</code>实例构造的相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (locallyScopedConn.getEnableQueryTimeouts() &amp;&amp; <span class="hljs-comment">// 这个连接配置项的默认值为true</span><br>        <span class="hljs-built_in">this</span>.timeoutInMillis != <span class="hljs-number">0</span><br>        &amp;&amp; locallyScopedConn.versionMeetsMinimum(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) &#123;<br>    timeoutTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancelTask</span>(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 该方法中产生NPE异常</span><br>    locallyScopedConn.getCancelTimer().schedule(timeoutTask,<br>                                                <span class="hljs-built_in">this</span>.timeoutInMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<strong>当启用了请求超时并且配置了超时时间，会构造并调度<code>CancelTask</code>实例，在构造<code>CancelTask</code>实例时，需要用到连接对象的<code>getProperties()</code>方法，由于<code>FabricMySQLConnectionProxy</code>类对于该方法的实现是直接返回null，因此触发了NPE</strong>。</p><p>结合<code>CancelTask</code>的<code>run()</code>方法中也可以看出，这是驱动层面对请求超时功能的实现：另起定时任务，在请求达到超时时间后，另起一个连接，kill掉之前的请求，则之前的查询请求会异常返回。</p><p>综上可以总结在驱动层面触发该异常的原因：<strong>使用Fabric连接方式执行带有超时设置的查询</strong>。</p><p>结论验证：调用驱动程序构造Fabric方式的连接并执行带有超时设置的查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class.forName(<span class="hljs-string">&quot;com.mysql.fabric.jdbc.FabricMySQLDriver&quot;</span>);<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql:fabric://&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>); <span class="hljs-comment">// enableQueryTimeouts配置默认开启</span><br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br>    statement.setQueryTimeout(<span class="hljs-number">10</span>);<br>    statement.executeQuery(<span class="hljs-string">&quot;select 1&quot;</span>); <span class="hljs-comment">// 应在此处抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>异常复现</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.NullPointerException</span><br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.StatementImpl<span class="hljs-variable">$CancelTask</span>.&lt;init&gt;(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">95</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.StatementImpl</span><span class="hljs-selector-class">.executeQuery</span>(StatementImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1546</span>)<br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method)<br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br>at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span><span class="hljs-selector-class">.invoke</span>(Method<span class="hljs-selector-class">.java</span>:<span class="hljs-number">498</span>)<br>at com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.jdbc</span>.LoadBalancingConnectionProxy<span class="hljs-variable">$ConnectionErrorFiringInvocationHandler</span><span class="hljs-selector-class">.invoke</span>(LoadBalancingConnectionProxy<span class="hljs-selector-class">.java</span>:<span class="hljs-number">107</span>)<br>at com<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.proxy</span>.<span class="hljs-variable">$Proxy21</span><span class="hljs-selector-class">.executeQuery</span>(Unknown Source)<br>at <span class="hljs-selector-tag">main</span>(Test<span class="hljs-selector-class">.java</span>:<span class="hljs-number">21</span>)<br></code></pre></td></tr></table></figure><h2 id="4-3-结合连接池和驱动程序确定异常发生的原因"><a href="#4-3-结合连接池和驱动程序确定异常发生的原因" class="headerlink" title="4.3 结合连接池和驱动程序确定异常发生的原因"></a>4.3 结合连接池和驱动程序确定异常发生的原因</h2><p>上面分别从连接池和驱动程序两个层面分析了异常的产生原因：</p><ol><li>驱动程序层面：使用Fabric连接方式执行带有超时设置的查询导致抛出异常</li><li>连接池层面：无特殊处理逻辑，仅是将驱动程序抛出的异常向上传递</li></ol><p>要最终确定结论，还需要将两者结合，即<strong>连接池和驱动程序的交互逻辑</strong>。</p><p>回到连接池<code>MySqlValidConnectionChecker.isValidConnection</code>方法，可以看出连接可用性检测的实现正是使用了驱动程序的queryTimeout功能，因此触发了NPE。</p><p>总结异常的发生原因：<strong>Druid连接池在对连接进行可用性检测时，使用了驱动程序的queryTimeout功能，由于Fabric连接的实现类未支持超时相关的能力，因此抛出异常。</strong></p><p>异常复现：根据上述结论可知，只需要配置连接池的可用性检测能力，即可触发异常</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;validationQuery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SELECT 1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;validationQueryTimeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3000</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>手动构造异常场景如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    properties.put(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;jdbc:mysql:fabric://&quot;</span>);<br>    properties.put(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>);<br>    properties.put(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br>    properties.put(<span class="hljs-string">&quot;driverClassName&quot;</span>, <span class="hljs-string">&quot;com.mysql.fabric.jdbc.FabricMySQLDriver&quot;</span>);<br><br>    properties.put(<span class="hljs-string">&quot;validationQuery&quot;</span>, <span class="hljs-string">&quot;SELECT 1&quot;</span>);<br>    properties.put(<span class="hljs-string">&quot;validationQueryTimeout&quot;</span>, <span class="hljs-string">&quot;3000&quot;</span>);<br><br>    <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>    DruidDataSourceFactory.config(dataSource, properties);<br><br>    dataSource.getConnection();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5 解决方案"></a>5 解决方案</h1><p>遵循异常排查的方向，也从两个方向考虑解决方案：</p><ol><li>修改驱动程序</li><li>连接池配置变更</li></ol><h2 id="5-1-修改驱动程序"><a href="#5-1-修改驱动程序" class="headerlink" title="5.1 修改驱动程序"></a>5.1 修改驱动程序</h2><p>跟踪官方版本，直到官方支持的最新5.1.49版本，都没有解决该问题。在官方论坛发帖，官方回复已不再支持5.1版本的驱动程序更新。</p><h2 id="5-2-连接池配置变更"><a href="#5-2-连接池配置变更" class="headerlink" title="5.2 连接池配置变更"></a>5.2 连接池配置变更</h2><p>回顾问题产生的原因，在驱动程序中执行超时时间≠0的查询时会出现问题，查询语句和超时时间分别对应连接池的<code>validationQuery</code>和<code>validationQueryTimeout</code>配置，即当同时配置连接池的<code>validationQuery</code>查询语句和<code>validationQueryTimeout</code>&gt;0时会引发异常。因此只需要任意破坏一个条件即可。</p><p>一个直观的解决方案是配置<code>validationQueryTimeout</code>&#x3D;0即可。从实际执行流程看，可用性检测的sql语句一般都配置的比较简单，因此不会在执行时间上花费很长的时间，更常见的情况是MySQL服务异常导致连接不可用，而此时异步线程也无法连接上MySQL服务。因此该方案可行。</p><p>关于<code>validationQuery</code>配置的修改方案，通过查看<code>com.mysql.jdbc.StatementImpl#executeQuery</code>方法中的相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (sql.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>   <span class="hljs-keyword">if</span> (sql.startsWith(PING_MARKER)) &#123; <span class="hljs-comment">// PING_MARKER = &quot;/* ping */&quot;</span><br>      doPingInstead();<br>   <br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.results;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到以<code>/* ping */</code>开头的查询会被转换为特殊实现的ping方法。</p><p>配置<code>validationQuery=/* ping */ SELECT 1</code>并进行测试，<code>doPingInstead()</code>中会向Fabric连接实现类中的封装的<code>ReplicationConnection</code>进行可用性检测，不会发生异常。</p><h1 id="6-为什么使用Tomcat连接池不会出现异常"><a href="#6-为什么使用Tomcat连接池不会出现异常" class="headerlink" title="6 为什么使用Tomcat连接池不会出现异常"></a>6 为什么使用Tomcat连接池不会出现异常</h1><p>通过变更配置的方式解决了该问题后，自然的想到了，其他连接池是怎么处理。由于目前项目中主要使用的是Druid和Tomcat两种连接池，因此仅探究Tomcat连接池在连接可用性检测方面的相关实现。</p><p>连接池根据<code>testOnBorrow</code>，<code>testOnReture</code>，<code>testWhileIdle</code>的配置，在对应场景执行连接可用性检测。</p><p>连接可用性检测相关逻辑在<code>org.apache.tomcat.jdbc.pool.PooledConnection#validate(int, java.lang.String)</code>中，可以看到当连接不可用时该方法会返回false。因此要继续看上层的处理逻辑。</p><h2 id="6-1-testOnBorrow场景"><a href="#6-1-testOnBorrow场景" class="headerlink" title="6.1 testOnBorrow场景"></a>6.1 testOnBorrow场景</h2><p>该场景下对连接的可用性检测由<code>org.apache.tomcat.jdbc.pool.DataSourceProxy#getConnection()</code>触发进入<code>org.apache.tomcat.jdbc.pool.ConnectionPool#borrowConnection(int, java.lang.String, java.lang.String)</code>中。时序图如下：</p><p><img src="/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B%E6%9A%B4%E9%9C%B2MySQL%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8FFabric%E8%BF%9E%E6%8E%A5NullPointerException%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%A3%80%E5%87%BA%E6%A3%80%E6%B5%8BborrowConnection%E6%96%B9%E6%B3%95%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Tomcat连接池检出检测borrowConnection方法时序图"></p><p>在1.1中，首先验证连接可用性（失败并返回false），尝试重新连接并再次进行可用性检测（再次失败并返回false），最终抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//validation failed.</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">&quot;Failed to validate a newly established connection.&quot;</span>);<br></code></pre></td></tr></table></figure><p>在1.2中，由于1.1抛出了异常，因此会尝试重新建立一个连接(1.2.1)，并再次验证连接可用性(1.2.2)，但此时的可用性验证是连接创建场景，因此使用的是initSQL配置或<code>connection.isValid()</code>方法，由于未配置initSQL参数且Fabric未实现该方法，因此1.2.2成功返回，继而该连接能够成功返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">con.validate(PooledConnection.VALIDATE_INIT) <span class="hljs-comment">// 不同VALIDATE模式的验证逻辑可能不同</span><br></code></pre></td></tr></table></figure><h2 id="6-2-testWhileIdle场景"><a href="#6-2-testWhileIdle场景" class="headerlink" title="6.2 testWhileIdle场景"></a>6.2 testWhileIdle场景</h2><p>testWhileIdle场景由<code>org.apache.tomcat.jdbc.pool.ConnectionPool.PoolCleaner#run</code>定时线程触发执行<code>org.apache.tomcat.jdbc.pool.ConnectionPool#testAllIdle</code>对连接池中的空闲线程进行检测，时序图如下：</p><p><img src="/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B%E8%83%BD%E5%8A%9B%E6%9A%B4%E9%9C%B2MySQL%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8FFabric%E8%BF%9E%E6%8E%A5NullPointerException%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/Tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8BtestAllIdle%E6%96%B9%E6%B3%95%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="Tomcat连接池空闲检测testAllIdle方法时序图"></p><p>1.1中调用的检测方法依然是<code>org.apache.tomcat.jdbc.pool.PooledConnection#validate(int, java.lang.String)</code>，因此检测结果依然是false。对于检测为不可用的连接，则触发1.2和1.3对连接进行释放。</p><p>这就导致了当触发定时检测时，所有未使用中的连接都会被抛弃。虽然对功能无影响，但频繁的释放和创建连接对性能有一定影响。</p><h2 id="6-3-testOnReturn场景"><a href="#6-3-testOnReturn场景" class="headerlink" title="6.3 testOnReturn场景"></a>6.3 testOnReturn场景</h2><p>使用场景不多，但易得，调用的检测方法也是相同的，并且也会对连接进行抛弃。最后导致每个连接都只能被使用一次就销毁。</p><h1 id="7-引申：是否可以在驱动程序层面解决这个问题"><a href="#7-引申：是否可以在驱动程序层面解决这个问题" class="headerlink" title="7 引申：是否可以在驱动程序层面解决这个问题"></a>7 引申：是否可以在驱动程序层面解决这个问题</h1><p>根据前面的分析可以看出，该问题<strong>最直接的原因在于Fabric连接未实现超时机制需要调用的相关方法</strong>，因此如果想在驱动程序层面解决该问题，最直接的想法就是对Fabric实现类中的对应方法进行实现。</p><h2 id="7-1-修改Fabric连接类支持超时机制"><a href="#7-1-修改Fabric连接类支持超时机制" class="headerlink" title="7.1 修改Fabric连接类支持超时机制"></a>7.1 修改Fabric连接类支持超时机制</h2><p>可以从<code>CancelTask</code>类的相关方法看到，超时机制的实现思路就是在构建时记录下<code>Connection</code>对象和<code>Connection</code>的连接快照信息，在发生超时后根据这些信息在相应的服务器上执行<code>kill query</code>指令。</p><p>查看代码可以看到在执行中可能需要调用<code>Connection</code>对象的<code>realClose()</code>、<code>duplicate()</code>、<code>getURL()</code>、<code>getProperties()</code>来。</p><p>考虑<code>getURL()</code>、<code>getProperties()</code>等快照信息获取方法在不同使用场景下的实现要求：</p><ol><li>在超时机制使用场景下，这些方法应该要能够明确的指示出当前实际的连接信息。</li><li>在通用场景下，这些方法应该能够指示出当前Fabric连接对象的生成信息。</li></ol><p>也就是说这些方法在实现上受限于特定场景和通用场景的矛盾。因此使用该方案支持超时机制不是很合适。</p><h2 id="7-2-修改超时机制的实现方式"><a href="#7-2-修改超时机制的实现方式" class="headerlink" title="7.2 修改超时机制的实现方式"></a>7.2 修改超时机制的实现方式</h2><p>由于当前流程执行不通，因此考虑在上级流程中进行修改。</p><p>例如，可以把生成<code>CancelTask</code>实例的职责委托给具体的<code>Connection</code>类，则Fabric连接实现类可以构建自己的<code>CancelTask</code>子类来实现超时机制处理方案。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>本文从源码层面分析了一个由Druid连接池版本升级暴露出的5.1版本MySQL驱动程序NullPointerException的产生原因。并基于异常的产生原因和驱动程序发展现状，采用连接池配置变更的方式解决该问题，并在理论上讨论了驱动程序源码修改的解决方案。</p><p>分层是目前程序设计的最基本思想。因此在出现问题时，也可以以各层为边界进行排查；同样的，在解决问题时，也可以以各层为单位寻求合适的解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL Connector/J</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Druid</tag>
      
      <tag>MySQL Connector/J</tag>
      
      <tag>连接池</tag>
      
      <tag>驱动程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo在github上搭建个人博客</title>
    <link href="/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文以工程实践的方式，按照需求提出、方案选择、开发实施、测试上线的流程，描述了为什么会有搭建博客系统的需求、如何使用hexo框架搭建博客系统并自动构建托管到github.io上的完整过程。特别地，对于开发实施部分，是根据实操的情况，采用不断地提出需求和问题并解决的方式来描述的。</p><span id="more"></span><h1 id="1-需求提出"><a href="#1-需求提出" class="headerlink" title="1 需求提出"></a>1 需求提出</h1><p>费曼学习法作为一个被广泛认可的学习方式，其中提出的输出步骤，可以说是整个学习法的最重要的部分。相比于阅读、听课等输入，输出有时被认为是一种更高效的学习方式：输出能够帮助加深印象，并帮助了解自己在哪个部分有所欠缺。</p><p>文章&#x2F;博客作为一种系统性的知识载体，可以认为是一种很好的输出方式。其中，博客又以其行文格式开放的特点被大家广泛使用。</p><p>在技术门槛和成本逐渐降低的今天，自己手动搭建一个由自己定制化的博客也不失为一种让人心动的方式。所以，拥有一个属于自己的个人博客，也成为一个自然而然的需求。</p><p>当然，由于博客仅是一个平台，因此不应在搭建上花费过多的精力。</p><p>所以，最终的完整需求是<strong>低成本地搭建个人博客网站</strong>。</p><h1 id="2-方案"><a href="#2-方案" class="headerlink" title="2 方案"></a>2 方案</h1><p>开源的、简单的方案总是更容易受到大家的青睐。查了一些资料后，最终选择了比较广泛使用的hexo搭建博客+github.io托管的方案。</p><p>hexo是一个基于node.js的、快速、简洁且高效的博客框架。支持使用markdown解析文章，并可以快速生成静态网页，同时支持主题的定制。</p><p>github pages是github为个人&#x2F;组织、项目提供的一个网站。只需编辑并推送，对应的改动就会在网页上生效。而其中的github.io是github pages为个人提供的免费网站。</p><h1 id="3-软件安装"><a href="#3-软件安装" class="headerlink" title="3 软件安装"></a>3 软件安装</h1><p>必选的需要安装node.js、hexo、git。另外还安装github的图形界面客户端github desktop。</p><p>node.js：直接在官网 <a href="http://nodejs.org/">http://nodejs.org/</a> 下载安装包运行安装即可。</p><p>hexo：参考官方中文文档进行安装： <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a> 。</p><h1 id="4-建站"><a href="#4-建站" class="headerlink" title="4 建站"></a>4 建站</h1><p>hexo由于其简单易用的特点，其搭建过程也十分容易，在官方文档中有详细的描述，因此主要是参考官方文档来进行。</p><h2 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h2><p>参考 <a href="https://hexo.io/zh-cn/docs/setup">https://hexo.io/zh-cn/docs/setup</a> 和 <a href="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a> 部分。</p><ol><li>执行初始化</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init</span><br>INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git<br>INFO  Install dependencies<br>npm WARN config global `--global`, `--local` are deprecated. Use `--location=global` instead.<br>INFO  Start blogging with Hexo!<br></code></pre></td></tr></table></figure><p>出现最后一句【INFO  Start blogging with Hexo!】表示初始化成功。</p><p><em>注：初始化需要在一个空文件夹中执行。上传到github.io仓库前需要将生成的文件内容复制到对应的本地仓库中。</em></p><ol start="2"><li>解析依赖</li></ol><p>初始化结果中的node_modules文件夹为外部依赖包（类比lib）。官方文档中，在初始化后，又对依赖显式地进行了重新解析，因此实际操作中也删除该文件夹并重新执行依赖解析。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install</span><br>npm WARN config global `--global`, `--local` are deprecated. Use `--location=global` instead.<br>npm WARN deprecated source-map-resolve@0.6.0: See https://github.com/lydell/source-map-resolve#deprecated<br><br>added 240 packages, and audited 241 packages in 5s<br><br>19 packages are looking for funding<br>  run `npm fund` for details<br><br>found 0 vulnerabilities<br></code></pre></td></tr></table></figure><ol start="3"><li>本地启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo server</span><br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><p>使用浏览器测试可以正常访问。</p><h2 id="4-2-支持静态网页"><a href="#4-2-支持静态网页" class="headerlink" title="4.2 支持静态网页"></a>4.2 支持静态网页</h2><p>参考 <a href="https://hexo.io/zh-cn/docs/commands#generate">https://hexo.io/zh-cn/docs/commands#generate</a> ，生成静态网页并启动，访问正常。</p><p>在测试过程中发现默认生成的静态网页的地址是“&#x2F;日期&#x2F;博客标题”的格式，根据 <a href="https://hexo.io/zh-cn/docs/permalinks">https://hexo.io/zh-cn/docs/permalinks</a> 的说明，生成的静态网页的默认地址格式为“&#x2F;博客创建日期&#x2F;博客路径&#x2F;博客标题”。如果其中的创建日期和博客路径发生变化，那么相应的外部引用就失效了，因此希望地址中采用相对稳定不会变化的内容来标识。根据文档提供的可选值，最终决定选择“&#x2F;文章标题”作为静态地址格式。</p><p>根据文档说明，调整配置。重新生成静态网页后测试，功能符合预期。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">permalink:</span> <span class="hljs-string">:post_title/</span><br></code></pre></td></tr></table></figure><h2 id="4-3-常用功能"><a href="#4-3-常用功能" class="headerlink" title="4.3 常用功能"></a>4.3 常用功能</h2><h3 id="4-3-1-资源引用"><a href="#4-3-1-资源引用" class="headerlink" title="4.3.1 资源引用"></a>4.3.1 资源引用</h3><p>出于资源管理的方便性考虑，希望将博客中引用的资源文件放在与文章同级的同名的文件夹中。由于官方提供的md文档中没有使用到图片等外部资源，因此需要进行可行性测试。</p><p>使用官方的hello-world.md示例测试图片资源的引用。创建hello-world文件夹并放入一张图片，在hello-world.md中使用md语法引用该图片，启动后图片无法展示。</p><p>参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a> ，开启post_asset_folder配置。重新生成后测试可达成需求。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><em>注：如果仅修改post_asset_folder配置，不修改permalink配置，则网页中的图片是无法正常解析的。可以从hexo g命令的输出结果中看到，图片文件被保存为“&#x2F;日期&#x2F;博客标题&#x2F;图片文件名”，而静态页中的图片引用为“&#x2F;博客标题&#x2F;图片文件名”，因此解析不到。</em></p><h3 id="4-3-2-分类-x2F-标签-x2F-文件目录的规划"><a href="#4-3-2-分类-x2F-标签-x2F-文件目录的规划" class="headerlink" title="4.3.2 分类&#x2F;标签&#x2F;文件目录的规划"></a>4.3.2 分类&#x2F;标签&#x2F;文件目录的规划</h3><p>需求描述：</p><ol><li>主题&#x2F;关键词用于标识一篇博客的内容主要跟哪些方面有关，一篇博客可以有多个tag。</li><li>对于博客来说，关键词更适合作为体现内容的方式，分类只是逻辑上的一个粗略大类的划分。博客在物理上可以根据分来来进行文件夹划分。因此一篇博客仅属于一个分类。</li><li>博客目录按分类进行目录划分。</li></ol><p>解决方案：</p><p>在博客的Front-matter部分指定tags&#x2F;categories，来标识所属的分类和标签主题。</p><h2 id="4-4-主题选择"><a href="#4-4-主题选择" class="headerlink" title="4.4 主题选择"></a>4.4 主题选择</h2><p>根据 <a href="https://hexo.io/zh-cn/docs/themes">https://hexo.io/zh-cn/docs/themes</a> 进行主题更改。一般来说，各主题都会提供详细的官方文档。</p><p>我选择的是fluid主题： <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a> 。</p><p>一般主题内都有一些功能可选，如评论系统，阅读量统计等。实际选择valine作为评论系统和leadcloud平台进行访问统计。</p><h2 id="4-5-分类-x2F-标签展示页缺失"><a href="#4-5-分类-x2F-标签展示页缺失" class="headerlink" title="4.5 分类&#x2F;标签展示页缺失"></a>4.5 分类&#x2F;标签展示页缺失</h2><p>主题一般都是支持分类页和标签页的。在替换主题后，打开页面会显示**Cannot GET &#x2F;categories&#x2F;<strong>和</strong>Cannot GET &#x2F;tags&#x2F;**。这是因为页面本身不存在，因此首先需要生成这个页面，再由主题去解析展示。</p><p>根据 <a href="https://hexo.io/zh-cn/docs/commands#new">https://hexo.io/zh-cn/docs/commands#new</a> 内容，通过hexo new page tags在source文件夹下生成tags文件夹，其中包含一个index.md文件。修改该md文件，在Front-matter中增加</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;tags&quot;</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">&quot;tags&quot;</span><br></code></pre></td></tr></table></figure><p>由于不同的主题对这个页面的处理的方式不同，有的是根据type，有的是根据layout，有的直接根据文件夹名称，所以这边都加上了。</p><h1 id="5-部署到github-io"><a href="#5-部署到github-io" class="headerlink" title="5 部署到github.io"></a>5 部署到github.io</h1><h2 id="5-1-手动配置部署"><a href="#5-1-手动配置部署" class="headerlink" title="5.1 手动配置部署"></a>5.1 手动配置部署</h2><p>参考 <a href="https://hexo.io/zh-cn/docs/github-pages#%E7%A7%81%E6%9C%89-Repository">https://hexo.io/zh-cn/docs/github-pages#%E7%A7%81%E6%9C%89-Repository</a> 和 <a href="https://hexo.io/zh-cn/docs/one-command-deployment">https://hexo.io/zh-cn/docs/one-command-deployment</a> 。修改deploy配置项并进行部署推送，访问github.io对应地址，与本地访问结果相同。</p><h2 id="5-2-使用github-actions生成并自动部署静态网页"><a href="#5-2-使用github-actions生成并自动部署静态网页" class="headerlink" title="5.2 使用github actions生成并自动部署静态网页"></a>5.2 使用github actions生成并自动部署静态网页</h2><ol><li>修改hexo的deploy配置，将git存储库从http形式更改为ssh形式。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:xxx/xxx.github.io.git</span><br>  <span class="hljs-comment"># example, https://github.com/hexojs/hexojs.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在本地用git bash生成一对新的密钥</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -f HEXO_DEPLOY_KEY -C &quot;HEXO_DEPLOY_KEY&quot;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在部署静态网页的仓库，即github.io仓库，打开settings，打开Deploy keys，添加一个新的key，上传公钥，即刚生成的pub文件内容，名字为HEXO_DEPLOY_KEY_PUB，需要勾选开启写权限。</p></li><li><p>在源码仓库，此处也是github.io仓库，settings，secrets，actions，添加私钥，名字为HEXO_DEPLOY_KEY_PRI。</p></li><li><p>配置actions</p><p>在源码仓库上进入 <code>Action -&gt; new workflow</code>，选择<code>set up a workflow yourself</code>，随便挑个模板；也可以在代码仓库中的<code>.github/workflow</code>添加一个<code>hexo-ci.yml</code>然后将以下内容放进该文件中。</p><p><strong>记得把&lt;&gt;中的 <code>blog_source_branch</code>, <code>username</code>, <code>username@email.address</code>替换成自己的实际值</strong></p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">HEXO</span> <span class="hljs-string">CI</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&lt;blog_source_branch&gt;</span><br>    <br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">A</span> <span class="hljs-string">job</span> <span class="hljs-string">to</span> <span class="hljs-string">deploy</span> <span class="hljs-string">blog.</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># Checkout private submodules(themes or something else).</span><br>          <span class="hljs-attr">submodules:</span> <span class="hljs-literal">true</span> <br><br>      <span class="hljs-comment"># Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12&#x27;</span> <span class="hljs-comment">#超过12的版本有几个warning，我不想处理</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-comment"># 定义了一个变量，对应secrets-actions里面配置的私钥的名字</span><br>          <span class="hljs-attr">HEXO_DEPLOY_KEY_PRI:</span> <span class="hljs-string">$&#123;&#123;secrets.HEXO_DEPLOY_KEY_PRI&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # 创建了一个ssh文件夹</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          # 把key复制进去</span><br><span class="hljs-string">          echo &quot;$HEXO_DEPLOY_KEY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 700 ~/.ssh</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          # 配置git</span><br><span class="hljs-string">          git config --global user.name &quot;&lt;username&gt;&quot;</span><br><span class="hljs-string">          git config --global user.email &quot;&lt;username@email.address&gt;&quot;</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          # 安装hexo</span><br><span class="hljs-string">          npm i -g hexo-cli</span><br><span class="hljs-string">          npm i</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">deploy</span><br></code></pre></td></tr></table></figure><p>配置后，就会在每次push到对应分支的时候触发这个Action，自己生成并部署hexo了。</p><h1 id="6-已知问题"><a href="#6-已知问题" class="headerlink" title="6 已知问题"></a>6 已知问题</h1><ol><li>博客标题中不能出现html的url实体符号，生成的静态网页路径会不正确。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的并发安全性问题论述</title>
    <link href="/java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E8%BF%B0/"/>
    <url>/java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文从并发安全性的定义出发，描述了什么是安全性，以及Java中对线程安全类的定义。然后列举了几个常见的安全性问题，并根据这些问题提出了<strong>安全性问题的产生条件是不恰当地对共享可变资源进行并发访问</strong>。接着针对该产生条件提出了基本解决思路，并简单地演示了Java提供的应对安全性问题的工具的基本使用方式。</p><span id="more"></span><h1 id="1-安全性问题的定义"><a href="#1-安全性问题的定义" class="headerlink" title="1 安全性问题的定义"></a>1 安全性问题的定义</h1><p>安全性的<strong>核心是正确性</strong>。</p><p>当多个线程并发执行时，如果执行结果的正确性，依赖于运行时环境的调度方式，就出现了安全性问题。</p><p>在Java中，对于一个类来说，当多个线程并发访问该类的同一个实例时，在没有任何额外的同步和协同的情况下，若不论运行时环境采用何种调度方式、这些线程如何交替执行，所有对这个实例的操作都能表现出预期的行为，则称这个类是线程安全的，即无安全性问题。</p><h1 id="2-安全性问题示例"><a href="#2-安全性问题示例" class="headerlink" title="2 安全性问题示例"></a>2 安全性问题示例</h1><h2 id="2-1-先检查后执行"><a href="#2-1-先检查后执行" class="headerlink" title="2.1 先检查后执行"></a>2.1 先检查后执行</h2><p>先检查后执行指的是，对一个资源的写入操作依赖于该资源的当前值。如果对这种操作不加以控制，当多个线程交替执行时，就有可能出现问题。</p><p>i++操作就是一个经典的先检查后执行的示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span>&#123;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>当并发地执行上述代码片段时，多个线程会并发地对共享变量i所在的内存地址进行可分割的”读取-修改-写入”操作，在<strong>特定的时序条件</strong>下，就可能出现部分线程的操作被覆盖的问题。</p><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E8%BF%B0/i++%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.png" alt="i++问题描述"></p><p>容易想到，只要将”读取-修改-写入”操作<strong>变为不可分割的一个完整操作</strong>，就可以解决该问题。</p><h2 id="2-2-高速缓存导致的数据失效"><a href="#2-2-高速缓存导致的数据失效" class="headerlink" title="2.2 高速缓存导致的数据失效"></a>2.2 高速缓存导致的数据失效</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> ready;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">while</span>(!ready)<br>        Thread.yield();<br>    System.out.println(number);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    number=<span class="hljs-number">2</span>;<br>    ready=<span class="hljs-literal">true</span>;<br>&#125;).start();<br></code></pre></td></tr></table></figure><p>读线程可能会永远循环下去，因为它永远都看不到ready的值发生改变，而是始终在使用已经失效的ready字段的数据。</p><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E8%BF%B0/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.png" alt="缓存数据过期问题描述"></p><p>容易看出，只要能将对数据更新通知到其他使用者，即可解决不可见问题。</p><h2 id="2-3-重排序导致的数据失效"><a href="#2-3-重排序导致的数据失效" class="headerlink" title="2.3 重排序导致的数据失效"></a>2.3 重排序导致的数据失效</h2><p>在上一个代码片段中，在运行时，处理器可能会出现先更新ready值，再更新number值。因为从单线程的执行结果上来看，无论先更新哪个值，最终的结果都是正确的。但是另一个线程并不知道这个情况，因此如果在更新ready值之后，执行线程切换，那么读线程看到number的值为0。这种运行时对指令的执行顺序进行调整的情况事前几乎无法判断。</p><p>容易想到，只要能禁止编译器、处理器或运行时对指令的执行顺序进行调整，即可解决这类不可见问题。</p><h1 id="3-安全性问题的解决方案"><a href="#3-安全性问题的解决方案" class="headerlink" title="3 安全性问题的解决方案"></a>3 安全性问题的解决方案</h1><p>出现安全性问题的根本原因在于<strong>不恰当地对共享可变资源进行并发访问</strong>。只有同时满足这几个条件时，才会存在安全性问题。</p><p>因此，要解决安全性问题，只需要破坏其中任一条件即可。</p><h2 id="3-1-并发访问"><a href="#3-1-并发访问" class="headerlink" title="3.1 并发访问"></a>3.1 并发访问</h2><p>当程序在<strong>单线程环境运行</strong>时，所有的资源在逻辑上都成为了线程独享的，即使这些对象在堆上生成，感觉也像是在线程栈中生成的一样。因为没有其他线程能够操作，因此就不会出现安全性问题。</p><h2 id="3-2-可变资源"><a href="#3-2-可变资源" class="headerlink" title="3.2 可变资源"></a>3.2 可变资源</h2><p>在“先检查后执行”问题中，变量i是一个可变的，多个线程可以同时对它随意读写。</p><p>在一些场景中，可以<strong>将共享变量设置为不可变</strong>（即使用final关键字修饰）。对于不可变资源，由于无法进行更新，只能进行读取，因此总是安全的。</p><h2 id="3-3-共享资源"><a href="#3-3-共享资源" class="headerlink" title="3.3 共享资源"></a>3.3 共享资源</h2><p>比将程序改为串行的方式更进一步，在运行时将数据<strong>限制在当前线程中</strong>，例如方法中的局部变量，通过ThreadLocal实现的线程封闭。这些数据不会被多个线程同时操作，因此就不存在安全性问题。</p><h2 id="3-4-不恰当访问"><a href="#3-4-不恰当访问" class="headerlink" title="3.4 不恰当访问"></a>3.4 不恰当访问</h2><p>更多的情况下，我们使用并发，就代表着我们是真的需要并发，真的需要同时操作共享数据。比如计数器资源，单例资源等等。那么就只能对资源的并发访问进行<strong>适当的同步</strong>，使得这些资源在并发访问的场景下能得到符合预期的结果。</p><h1 id="4-同步"><a href="#4-同步" class="headerlink" title="4 同步"></a>4 同步</h1><p>安全性问题最终都可以归结为两个方面的问题：<strong>多个应该被一次性执行完的指令被分开执行导致资源呈现中间状态的原子性问题</strong>，和<strong>不同线程没有及时了解到数据变更的可见性问题</strong>。</p><p>因此，解决不恰当访问问题的基本方法在于解决原子性和可见性的问题。即<strong>操作非原子</strong>和<strong>修改不可见</strong>的问题。Java提供了加锁和声明volatile变量的方式来解决这两个问题。</p><h2 id="4-1-加锁"><a href="#4-1-加锁" class="headerlink" title="4.1 加锁"></a>4.1 加锁</h2><p><strong>需要一次性执行完的指令片段被称为临界区</strong>。通过对临界区进行加锁，保证每次只有一个线程能执行这些操作，且能够一次性执行完这些操作。同时，下一个进入获得锁进入临界区的线程，能够完整地看到上一个释放锁的线程对数据执行的所有操作的结果。</p><p>因此，<strong>加锁同时解决了原子性和可见性的问题</strong>。</p><h2 id="4-2-volatile变量"><a href="#4-2-volatile变量" class="headerlink" title="4.2 volatile变量"></a>4.2 volatile变量</h2><p>在CPU缓存导致的数据过期问题中，对ready字段的修改和number字段的修改并没有原子性的要求，而只是希望主线程对这两个字段的修改对另一个线程能够可见，即可见性要求。Java提供了可见性保证手段：volatile关键字。对于被声明了volatile关键字的变量，<strong>在执行写入时，处理器会立刻将其写入内存中，并通知其他处理器该变量的值已经更新了，之前的缓存已经失效了；因此在读取时，处理器会到内存中进行读取最新的值，而不是一直使用缓存中的失效值。</strong></p><p>可以看出，在volatile变量被修改后，到另一个线程读取到新值前，中间仍然有一些时延，依然可能读取到过期值。因此，volatile变量值保证了变量的可见性，但没有保证原子性。</p><p>同时，volatile关键字还具有<strong>禁止重排序</strong>的语义。在对volatile变量进行写入操作前的所有修改，在对volatile变量进行读取操作时，都是可见的。</p><h1 id="5-使用同步解决安全性问题"><a href="#5-使用同步解决安全性问题" class="headerlink" title="5 使用同步解决安全性问题"></a>5 使用同步解决安全性问题</h1><h2 id="5-1-解决原子性问题"><a href="#5-1-解决原子性问题" class="headerlink" title="5.1 解决原子性问题"></a>5.1 解决原子性问题</h2><p>对于并发执行i++这类“先检查后执行”的操作导致的原子性问题，Java中提供了两种方法来保证操作的原子性。</p><h3 id="5-1-1-加锁"><a href="#5-1-1-加锁" class="headerlink" title="5.1.1 加锁"></a>5.1.1 加锁</h3><p>最简单直接的方法就是对临界区进行加锁操作，使得多个线程都能完整地执行i++操作从而保证了原子性，同时每个线程对变量i的修改都能立刻被下一个线程看到，从而保证了可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span>&#123;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E8%BF%B0/i++%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="i++问题描述"></p><h3 id="5-1-2-原子类"><a href="#5-1-2-原子类" class="headerlink" title="5.1.2 原子类"></a>5.1.2 原子类</h3><p>synchronized的加锁行为体现的是一种悲观的加锁方式，也就是当前线程认为在自己进行操作数据期间，一定会有其他线程来竞争资源，因此当前线程要把资源锁住，即独占该资源，让其他的线程不能同时操作。这样就避免了竞争。</p><p>乐观的加锁方式则是认为在当前线程进行操作数据期间，不会有其他线程来竞争资源，或者只会进行少量几次的竞争，因此当前线程不对资源进行独占的方式，而是以CAS的方式对数据进行更新。CAS指的是compare and set，意为如果当前的值与期望值相同，就将其更新为给定的新值。这其实依然是一种“先检查再执行”的操作，但是CPU对其原子性进行了保证，因此可以将其视为一个原子操作。Java中提供的AtomicInteger原子类在进行数据更新时，就是使用这种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span>&#123;<br>    i.incrementAndGet();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-解决可见性问题"><a href="#5-2-解决可见性问题" class="headerlink" title="5.2 解决可见性问题"></a>5.2 解决可见性问题</h2><p>Java中提供的volatile关键字包含了这两个功能：当对volatile变量进行更新时，该更新会立刻被写入内存中，并通知其他处理器下一次要从内存中读取新值而不再使用自己的缓存；对volatile变量进行更新前执行的操作，在执行volatile变量的更新后，都要立即可见。也就是说，在对volatile变量进行更新前执行的所有操作，都不能被重排序到volatile变量更新后再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> ready;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> number;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">while</span>(!ready)<br>        Thread.yield();<br>    System.out.println(number);<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    number=<span class="hljs-number">2</span>;<br>    ready=<span class="hljs-literal">true</span>;<br>&#125;).start();<br></code></pre></td></tr></table></figure><p><img src="/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E8%BF%B0/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.png" alt="缓存数据过期问题解决"></p><p>通过将ready和number变量声明为volatile，就能有效地解决两种不同原因引起的不可见问题。首先，当第二个线程将ready改为true后，会立即将其写入内存中；并通知所有其他的CPU，对ready变量的缓存已经失效了，应该重新从内存中读取；在第一个线程被唤醒后，再次读取ready字段进行判断时，发现该数据已过期，因此重新从内存中读取，就能得到ready&#x3D;true。其次，将变量ready声明为volatile也意味着，在执行ready&#x3D;true之前的number&#x3D;2操作，必须在ready&#x3D;true前执行完成，因此第一个线程看到的number值总为2。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>避免并发问题最好的方式就是不使用并发。对于CPU密集型程序，在单核机器上只需要一个线程来执行任务程序就可以了，过多的线程反而会降低吞吐量。在并发程序设计阶段，也应该尽量对任务进行彻底的分离，使得每个线程执行的任务相互之间没有关联。</p><p>当然更多的情况下，我们使用并发，确实是因为我们真的需要并发，真的需要共享数据。那么此时，如何安全的对共享数据进行并发地修改和访问，就成为了程序设计的重点。我们要做的就是制定合适的加锁策略，适当的封装，使得需要被并发访问的类成为线程安全的类。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发基本理论论述</title>
    <link href="/%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA%E8%AE%BA%E8%BF%B0/"/>
    <url>/%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA%E8%AE%BA%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文从并发出现的背景出发，介绍了并发执行方式解决了串行执行方式导致的资源利用率低的问题。并据此提出了只有当任务存在阻塞的前提下，使用并发才能带来系统资源利用率提升的效果。凡事都有两面性，使用并发在带来系统吞吐量提升的同时，也可能引入一些风险，本文对这些风险也进行了一些简单的讨论。</p><span id="more"></span><h1 id="1-并发的出现"><a href="#1-并发的出现" class="headerlink" title="1 并发的出现"></a>1 并发的出现</h1><h2 id="1-1-串行执行"><a href="#1-1-串行执行" class="headerlink" title="1.1 串行执行"></a>1.1 串行执行</h2><p>早期的计算机主要用来执行逻辑简单但过程繁琐的数学计算任务。由于在物理环境下编程难度很大，每次使用时，全程只运行一个程序，执行一个任务，该任务独享所有系统资源。当有多个任务时，只能串行的一个一个执行。</p><p><strong>由于计算机不同组成部分之间的运行速度不同，在协同工作时，运行速度较快的模块需要等待运行速度较慢的模块完成计算后才能继续处理。</strong>如磁盘、网络等外存，它们与CPU的处理速度差距甚至可以达到5个数量级的差距。</p><p>显然，对于一个需要外存参与的任务，与花费在外存I&#x2F;O等待上的时间相比，实际用在任务计算上的时间甚至可以忽略不计了。因此，<strong>在不改变串行执行方式的前提下，要想缩短多任务执行的总时长，只能缩短外存的I&#x2F;O等待时间</strong>。但即使是目前速度最快的固态硬盘，也无法将I&#x2F;O时间缩短到与CPU指令执行时间同一个数量级。</p><p>CPU的长时间等待导致其利用率极低。自然地，人们希望CPU能够转而执行其他的计算任务，而不是浪费时间在等待上。</p><h2 id="1-2-并发执行"><a href="#1-2-并发执行" class="headerlink" title="1.2 并发执行"></a>1.2 并发执行</h2><p>基于对多任务能够同时执行的需求，就需要<strong>一个能够对系统资源进行调度和分配的角色，它能对任务和资源进行管理，将资源合理的分配给所有任务。这个角色就是操作系统。</strong></p><p>操作系统对CPU的执行时间进行分片，并分配给每个程序使用。当一个程序A进入外存I&#x2F;O等待或者使用完了本次分配的时间片，CPU就将程序A的执行现场保存下来，然后选择另一个待执行的程序B开始进行处理；当外存I&#x2F;O处理就绪或者时间片使用权又轮到程序A时，CPU又将程序A的执行现场恢复回来，并从上次切出的地方开始继续执行，直到再次出现外存I&#x2F;O等待或者分配的时间片用完或者程序A执行结束。</p><p>时间分片的运行方式，使得每个任务能交替地使用CPU资源。同时，当一个程序在等待的时候，可以先运行另一个程序，这无疑提高了CPU的资源利用率。</p><h1 id="2-并发与并行的区别"><a href="#2-并发与并行的区别" class="headerlink" title="2 并发与并行的区别"></a>2 并发与并行的区别</h1><p><strong>当多个任务在同一个CPU上通过时间分片的方式交替运行时，称为并发执行。当多个任务在多个CPU上同时进行计算时，称为并行执行。</strong></p><p>在一个单核CPU上，在编辑文本时还能播放音乐，在浏览网页时还能播放视频，这是并发机制在起作用；而在多核CPU上同样能完成这些工作，但这可能是由于并行执行引起的。</p><p>并发和并行的概念经常被混淆。由于并发执行引起的上下文切换所消耗的时间相比于人类可感知到的时间停顿来说很小，因此不论是并发还是并行，看起来都是多个任务在同时运行。</p><h1 id="3-并发的优势及使用前提"><a href="#3-并发的优势及使用前提" class="headerlink" title="3 并发的优势及使用前提"></a>3 并发的优势及使用前提</h1><p>任务的复杂程度不同，执行这些任务所需要的资源也不同，计算机中参与任务执行的组成部分也不同。对于计算10的阶乘这样的简单任务，只需要用到CPU和内存即可，甚至可以不需要内存参与，单纯由CPU也能完成；而对于比如银行报表统计这类数据量大，计算逻辑复杂的任务，除了CPU和内存外，还需要文件系统的参与，甚至可能还需要网络系统的参与。<strong>根据执行任务所需的资源不同，使用串行和并发的方式来执行多任务，得到的总体性能效果也是不同的。</strong></p><p>串行执行不需要外部资源参与的多任务，执行总时间可表示为<br>$$<br>总时间&#x3D;\sum任务计算时间<br>$$<br>并发执行不需要外部资源参与的多任务，执行总时间可表示为<br>$$<br>总时间&#x3D;\sum(任务计算时间+上下文切换时间)<br>$$<br>串行执行需要外部资源参与的多任务，执行总时间可表示为<br>$$<br>总时间&#x3D;\sum(任务计算时间+任务I&#x2F;O等待时间)<br>&#x3D;\sum(1+10^5)任务计算时间<br>$$<br>并发执行需要外部资源参与的多任务，执行总时间可表示为<br>$$<br>总时间&#x3D;\sum(任务计算时间+上下文切换时间)<br>$$<br>上下文切换虽然也是一个比较重的操作，但相对于外存I&#x2F;O来说，依然是有多个数量级的差距。</p><p>从上述结果可以看出，当执行任务不需要外部资源参与时，使用并发相比串行执行需要多付出上下文切换的性能开销，总的执行时间反而更长了；而对于需要外部资源参与的任务，在等待时间里切换并执行其他任务，能够更充分的利用CPU。</p><p>因此，对于CPU密集型的任务，串行执行的效率更高；对于I&#x2F;O密集型的任务，并发执行的效率更高。可见，<strong>使用并发能够提升系统资源利用率的前提在于，任务的执行需要依赖于外部速度较慢的资源</strong>。</p><h1 id="4-使用并发带来的风险"><a href="#4-使用并发带来的风险" class="headerlink" title="4 使用并发带来的风险"></a>4 使用并发带来的风险</h1><p>任务程序的并发执行，意味着CPU资源和内存资源将会被共享。在不考虑高速缓存的情况下，CPU的作用只是进行计算，同一时间只能处理一个任务的计算，不同任务的计算不会互相影响；而内存作为存储单元，会被多个任务共享，如果没有正确地控制各个任务的行为，那么就有可能出现不同任务错误地使用相同的内存区域，进而引发一些不可控的问题。</p><p>因此，<strong>当内存被不同的程序错误地共享时，并发就可能导致问题。</strong>如果能将任务分解为互不依赖的子任务来并发执行，那么就不会出现问题。当然，在实际问题中难免任务之间存在相互依赖的场景，因此，讨论使用并发可能出现的问题及其解决之道是有意义的。</p><h2 id="4-1-安全性问题"><a href="#4-1-安全性问题" class="headerlink" title="4.1 安全性问题"></a>4.1 安全性问题</h2><p>当内存资源被共享时，最常见的就是安全性问题。安全性问题指的是并发执行任务的结果依赖于任务的执行时序。安全性问题来源于程序的并发运行及内存资源的读写共享。</p><p>使用自增操作符(++)对共享数据进行并发操作，经常被作为引入并发安全性问题概念的经典案例。这个案例十分简单但却很好的暴露出了安全性问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inc</span><span class="hljs-params">()</span>&#123;<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>当并发地执行上述代码片段时，多个线程会并发地对共享变量i所在的内存地址进行可分割的”读取-修改-写入”操作，在特定的时序条件下，就可能出现部分线程的操作被覆盖的问题。</p><p><img src="/%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA%E8%AE%BA%E8%BF%B0/i++%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.jpg" alt="i++问题描述"></p><p>要解决安全性问题，只需要破坏导致安全性问题的任一条件即可。例如通过使用单线程运行破坏并发运行条件；通过创建不可变对象破坏读写共享条件；通过线程同步机制破坏读写共享条件；通过只读共享破坏读写共享条件。</p><h2 id="4-2-活跃性问题"><a href="#4-2-活跃性问题" class="headerlink" title="4.2 活跃性问题"></a>4.2 活跃性问题</h2><p><strong>活跃性问题是指并发执行的任务无法及时的执行下去。</strong>活跃性问题常见于错误地使用了同步机制。活跃性问题是非常严重的问题，只能通过中止任务来进行恢复。并且这类问题都是在执行过程中动态的发生，一些代码检查工具也难以发现，因此排查十分的困难。</p><p>常见的活跃性问题有死锁，活锁，饥饿等。</p><h3 id="4-2-1-死锁"><a href="#4-2-1-死锁" class="headerlink" title="4.2.1 死锁"></a>4.2.1 死锁</h3><p>死锁的典型案例是哲学家进餐问题。最简单的版本是两个哲学家去吃饭，他们时而思考时而吃饭。桌上只有两只筷子，分别放在他们的左右手边，只有拿到一双筷子才能吃东西，并且吃到东西后才会将筷子放回。假设两个人同时拿到了右边的筷子，然后开始等待左边的筷子空出来，但是因为他们还没有吃到东西，因此又不放下已经拿到的筷子。那么大家就只能这么无限等待下去。</p><p><strong>当多个任务互相拥有着对方所需的资源，又在等待着对方拥有的资源，并且在得到自己需要的所有资源之前不会放弃已拥有的资源，这种情况将产生死锁。</strong></p><p>在并发环境下，当一个线程获取到了锁A，并尝试继续获取锁B，同时，另一个线程已经获取到了锁B，并尝试继续获取锁A。此时，双方都拿着对方所需的资源等待对方的资源，并且在获取到锁AB并完成计算之前双方都不会放弃自己手中的资源。那么这两个线程将一直这么等待下去，直到有外力对这种关系进行破坏。</p><p>死锁问题一般是由于没有以统一固定的顺序获取多个锁。例如上例中的锁AB，如果在获取锁前都根据字母顺序进行获取，即先获取锁A再获取锁B，则死锁不会发生。在一些动态加锁的场景中，比如转账业务中对转账方和收款方进行的加锁操作，如果以先获取转账方的锁再获取收款方的锁的逻辑进行锁获取，则当两个账户相互转账时，就有可能发生动态的锁顺序死锁，可以先对转账双方账号进行排序，再根据排序顺序进行加锁，来保证多个线程加锁的顺序能一致。</p><h3 id="4-2-2-活锁"><a href="#4-2-2-活锁" class="headerlink" title="4.2.2 活锁"></a>4.2.2 活锁</h3><p><strong>当多个相互协作的线程都对彼此进行响应从而修改各自的状态，并使得任何一个线程都无法继续执行时，就发生了活锁。</strong></p><p>在哲学家进餐问题中修改哲学家的行为，规定哲学家只能先拿左边的筷子，成功后再拿右边的筷子，并且如果右边的筷子没有拿到，那就将已拿到的筷子放回，然后重新尝试。那么可能出现这样的情况，两位哲学家同时拿起左边的筷子，同时发现右边没有筷子，同时放下左边的筷子，再同时拿起左边的筷子，这样循环往复下去，虽然他们一直有所动作，但是他们都无法完成进餐。</p><p>解决活锁的办法是引入随机等待。当因为没有获取到需要的资源而放弃已有的资源后，随机等待一段时间再开始进行重试。</p><h3 id="4-2-3-饥饿"><a href="#4-2-3-饥饿" class="headerlink" title="4.2.3 饥饿"></a>4.2.3 饥饿</h3><p><strong>当任务因为一直访问不到自己所需的资源时，就产生了饥饿问题。</strong></p><p>在哲学家进餐问题中修改哲学家的行为，规定哲学家在拿到一整双筷子后，就一直进餐，知道把桌上的东西都吃完。那么首先拿到一双筷子的哲学家在吃完东西之前都不会放弃筷子，也就导致另一位哲学家一直无法拿到筷子。</p><p>在并发环境下，如果一个线程在持有锁时执行一些无法结束的行为，如无限循环，那么其他需要这个锁的线程将永远无法得到它。</p><p>饥饿问题通常是由于一些依赖于具体执行平台的编码，比如指定线程优先级等。应该尽可能的避免这种编码，或显式的主动让出资源给优先级较低的线程，让它们有机会执行自己的任务。</p><h2 id="4-3-性能问题"><a href="#4-3-性能问题" class="headerlink" title="4.3 性能问题"></a>4.3 性能问题</h2><p><strong>性能问题是指不当使用并发导致的系统整体性能下降，吞吐量下降。</strong>显然的，当用于上下文切换花费的时间多于任务实际执行的时间时，使用并发来解决问题，就是一种得不偿失的方案。</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>当我们谈论并发时，更多的是在讨论如何充分的利用单个CPU资源。</p><p>使用并发来执行任务已经是当今不可避免的方式了。即使应用程序本身简单到只用到一个线程来执行，但在底层的运行时环境或者更基础的操作系统中，也一定还会有其他各式各样的后台任务在并发执行。</p><p>尽管现在硬件速度非常快、并且高级程序设计语言也对并发特性做了很多封装来降低编写并发程序的门槛、人们在进行程序设计时也会习惯性地对任务进行分解以期能以并发的方式来执行，但依然需要注意“无阻塞不并发”的原则。如果任务都只是计算，没有外部资源的等待，那么大可不必使用并发方式执行，即使不在乎几十毫秒的上下文切换开销，也应该意识到不使用并发就不会为程序编写引入更多的复杂性。</p>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
